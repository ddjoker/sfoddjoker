[TOC level=1-4]: # " "

- [排序算法](#排序算法)
    - [1. 排序的定义](#1-排序的定义)
        - [1.1. 排序的分类](#11-排序的分类)
            - [1.1.1. 是否消耗额外的空间](#111-是否消耗额外的空间)
            - [1.1.2. 稳定性](#112-稳定性)
    - [2.  八大算法的稳定性](#2--八大算法的稳定性)
        - [2.1. 直接插入排序](#21-直接插入排序)
        - [2.2. 希尔排序](#22-希尔排序)
        - [2.3. 冒泡排序](#23-冒泡排序)
        - [2.4. 快速排序](#24-快速排序)
        - [2.5. 直接选择排序](#25-直接选择排序)
        - [2.6. 堆排序](#26-堆排序)
        - [2.7. 归并排序](#27-归并排序)
        - [2.8. 基数排序](#28-基数排序)
    - [3.总结](#3总结)


# 排序算法

算法 ：9世纪波斯数学家提出的“al-Khowarizmi”

## 1. 排序的定义

输入：n个数（a1,a2,a3...an)
输出：n个数的排列（a1',a2',a3'...an')，使得a1'<=a2'<=a3'<=...<=an'

主要的排序算法有八种：直接插入排序，希尔排序（这两种统称为插入排序），冒泡排序，快速排序（这两种统称为交换排序），直接选择排序，堆排序（这两种统称为选择排序），归并排序，基数排序。

### 1.1. 排序的分类

#### 1.1.1. 是否消耗额外的空间

##### 1.1.1.1.  In-place sort

不占用额外内存或占用常数的内存)

1. 插入排序
2. 选择排序
3. 冒泡排序
4. 堆排序
5. 快速排序

##### 1.1.1.2. Out-place sort

1. 归并排序
2. 计数排序
3. 基数排序
4. 桶排序

当需要对大量数据进行排序时，In-place
sort就显示出优点，因为只需要占用常数的内存，更加可控。

#### 1.1.2. 稳定性

**什么是算法稳定性？**

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。

**算法稳定性的重要性**

算法稳定性为什么这么重要呢？

1. 在实际的应用中，我们交换的不一定只是一个整数，而可能是一个很大的对象，交换元素存在一定的开销；

2. 参照基数排序，不稳定排序是无法完成基数排序的。
   ![排序算法不稳定性](image/1357739159_8849.GIF)

##### 1.1.2.1. stable sort

1. 插入排序
2. 冒泡排序
3. 归并排序
4. 计数排序
5. 基数排序
6. 桶排序

##### 1.1.2.2. unstable sort

1. 选择排序
2. 快速排序
3. 堆排序

算法的不稳定性会

## 2.  八大算法的稳定性

### 2.1. 直接插入排序

[插入排序](./排序算法/插入排序.md)

其大致原理是：将数组分为无序区和有序区两个区，然后不断将无序区的第一个元素按大小顺序插入到有序区中去，最终将所有无序区元素都移动到有序区完成排序。

我们假设一个数组，元素已经排序为{1,5A,7,5B,9},其中前面三个已经排序完成，后面没有排序，即前面三个是有序区，后面两个是无序区，现在要将无序区的5B插入到有序区，则如果我们将元素插入到5A之前，我们需要往后移动两个元素，如果插入到5A之后，则需要移动一个元素，因此我们选择移动一个元素，而5A和5B也保持原来的顺序，因而直接插入排序是稳定的。

### 2.2. 希尔排序

[希尔排序](./排序算法/希尔排序.md)

其大致原理是：又称Gap缩小排序。先将序列按Gap划分为元素个数相同的若干组，使用直接插入排序法进行排序，然后不断缩小Gap直至为1，最后使用直接插入排序完成排序。希尔排序其实是直接插入排序的增强版。

我们来证明它是不稳定的，假设有一个数组{3,2A,2B,4}，我们要升序排列，按照算法，第一次Gap=2，即可以分为{3,2B}和{2A,4}两组，然后对每一组进行插入排序，可以排序成{2B,2A,3,4}，第二次Gap=1，由于插入排序是稳定的，所以2A和2B不会交换顺序了。由此可以看到，希尔排序是不稳定的。

### 2.3. 冒泡排序

[冒泡排序](./排序算法/冒泡排序.md)

其大致原理是：将序列划分为无序和有序区，不断通过交换较大元素至无序区尾完成排序。

熟悉冒泡排序的人一定知道，冒泡排序通过不断的交换元素，将无序区的最大（最小）元素往无序区搬运，因而和插入排序一样，为了减少其交换次数，冒泡排序是稳定的。

### 2.4. 快速排序

[快速排序](./排序算法/快速排序.md)

其大致原理是：不断寻找一个序列的中点，将小于该中点的元素搬移到中点左边，大于该中点的元素搬移到中点右边，或者反过来。然后对中点左右的序列递归的进行排序，直至全部序列排序完成，使用了分治的思想。

关于算法的稳定性有一点本来是打算后面再讲的，但是讲到快速排序就一定要说了。读者肯定注意到了，前面的插入排序和冒泡排序完全可以实现为不稳定算法，只是在比较元素决定是否交换的时候，是否加上等于号而已。快速排序更加显示了这一点，解释如下：

在算法导论里面，快速排序选择都是元素序列的最后一个元素，假设元素序列如下{3,9,5A,6,8,5B}，这种情况下，和上面的情况一下，稳不稳定还是看判断的时候是否出现等号，但是如果选择不是这样的，我们假设一种特殊状况：{3,9,5A,5B,6,8,5C}，算法的实现是选择中间的5B作为中点，则不论等号与否，都是不稳定的。实际上，算法导论的选择是非常有意义的，了解其算法过程的人可以看到，这样的选择极大的降低了交换元素的复杂度和移动元素的次数。算法导论中是加了等号的，即≤最后一个元素的值被移到了左边，因而快速排序是稳定的。

### 2.5. 直接选择排序

[选择排序](./排序算法/选择排序.md)

其大致原理是：将序列划分为无序和有序区，寻找无序区中的最小值和无序区的首元素交换，有序区扩大一个，循环最终完成全部排序。

我们还是假设一个序列{1,3,5,10A,10B,7}，看这个数列，假设前面三个是有序区，后面三个是无序区，则无序区中最小的元素是7，和无序区的首元素交换10A交换，则可以看到序列变成了{1,3,5,7,10B,10A}，然后继续，无序区就剩下{10B,10A}，我们又可以看到，这里又是一个等号问题，同样，前面的交换是必然的，而后面的交换（如果等于也要交换）则不是必然的，为了减少元素交换，直接选择排序是不稳定的。

### 2.6. 堆排序

其大致原理是：利用大根堆或小根堆思想，首先建立堆，然后将堆首与堆尾交换，堆尾之后为有序区。

考虑序列{9,5A,7,5B}，按照堆排序的算法走一遍（算法导论中用的是最大堆，这个序列也是用最大堆来设计的），很快就可以发现，输出序列为{5B,5A,7,9}，而且与等号无关，因此堆排序是不稳定的。

### 2.7. 归并排序

[归并排序](./排序算法/归并排序.md)

其大致原理是：将原序列划分为有序的两个序列，然后利用归并算法进行合并，合并之后即为有序序列。

归并排序一样是稳定的，但是归并排序的稳定性并不是为了减少元素交换次数，因为它的算法实现中没有元素交换这一概念。

### 2.8. 基数排序

[基数排序](./排序算法/基数排序.md)

其大致原理是：将数字按位数划分出n个关键字，每次针对一个关键字进行排序，然后针对排序后的序列进行下一个关键字的排序，循环至所有关键字都使用过则排序完成。具体请参见：算法总结系列之五:
基数排序(Radix Sort)

基数排序对多个关键字进行排序，并且这些关键字还是有优先级别的，对于整数来说，位数越高的数字优先级越高，而基数排序则是对优先级低的先排序，因此，基数排序对于整数是从个十百千万一个个去排序的。注意，这里必须使用稳定排序，否则，就会让原先的地位排序成果毁于一旦，最终的不到正确的排序结果。

基数排序不过是一种思想，其每一位的排序都需要稳定算法，否则无法得到正确的结果。

## 3.总结

算法稳定性到底为什么如此重要？上面提到的八种算法可以看到，其实很多算法都是可以实现稳定和不稳定两种情形的，那为什么选择稳定？一个基本原因就是减少元素交换次数，但是也有像归并排序这样的算法，与交换无关，那么稳定算法的意义在哪里呢？

稳定算法在单次排序的时候，意义并不显著，虽然上面提到减少元素交换，其实链表是可以避免这个消耗的，只不过操作比较复杂，其意义显示在基数排序中，即，我们要对多个关键词多次排序，这个时候，就一定要使用稳定算法。举一个现实的例子，比如排序的对象是人名，假设有以下两个人名：

    Smith, Alfred
    Smith, Zed

我们先按first name排序，再按照last name排序，按照first
name排序完成以后，就是上面的样子，再去按照last
name排序，如果算法不稳定，则顺序极就会颠倒，是不是？这里的last
name和first
name完全可以抽象成基数排序的不同位，不是稳定算法，就不能得到正确结果。


[^参考1:]: http://blog.csdn.net/xiazdong/article/details/8462393

[^参考2:]: http://www.cnblogs.com/lqminn/p/3642027.html

