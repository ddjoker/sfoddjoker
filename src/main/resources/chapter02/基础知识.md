[TOC level=4]: # " "

- [2.2 编程语言](#22-编程语言)
- [2.3 数据结构](#23-数据结构)
    - [2.3.1. 数组](#231-数组)
    - [2.3.2. 字符串](#232-字符串)
    - [2.3.3. 链表](#233-链表)
    - [2.3.4. 树](#234-树)
        - [常用的遍历方式](#常用的遍历方式)
        - [三种遍历的6种实现方式](#三种遍历的6种实现方式)
    - [2.3.5. 栈和队列](#235-栈和队列)


# 基础知识

## 2.2 编程语言

1. 实现SingleSon
   <https://github.com/lidong20141226/sfoddjoker/tree/master/src/main/java/chapter/chapter02/singleson>
   1. `SingleSonSingleThread ` 只能在单线程正常工作
   2. `SingleSonLockMode` 可以工作但是效率低
   3. `SingleSonLockMode2` 二次判断提高效率,可以在多线程使用
   4. `SingleSonStaticMode`
      确保单实例,在静态时候初始化,但不可控,会产生资源浪费
   5. `SingleSonInnerClassMode` 内部类事件,确保单实例的同时,增加可控性.

## 2.3 数据结构

| 常用数据结构          | 适用状态                 |
|:----------------------|:-------------------------|
| 数组                  | 连续内存存储数字和字符   |
| 字符串                | 连续内存存储数字和字符   |
| 链表     出现频率最高 | 注意代码的健壮性         |
| 树                    | 注意代码的健壮性         |
| 队列                  | 与递归紧密相关的数据结构 |
| 栈                    | 与广度遍历算法相关       |

### 2.3.1. 数组

因数组需要事先制定容量并根据大小分配内存，所以会可能在没有全部使用的情况下产生大量的空闲内存。所以数组的空间效率不是很好。

但是由于数组内存是连续的，所以根据下标可以在O(1)时间内读写任何数据,因此时间效率是很高的.
我们可以根据数组时间效率高的优点,组成简单哈希表:下标为KEey,值为Value.以适应高时间效率的问题解决.
`面试题35: 第一个只出现一次的字母`

为了解决数组空间效率不高的问题,设计多种动态数组.`ArrayList`
,先为初始化一个小的数组,之后超过时,重新分配一个新的空间,并将原有的数据都复制到新的数组中.
每次扩充都会产生大量的额外操作,对时间性能有负面影响,故尽量减少数组容量大小改变次数.

>面试题3:二维数组中的查找
>
>>在一个二维数组中,每一行都是按照从左到右递增的顺序排序,每一列都是从上到下递增的顺序排序.请完成一个函数,输入这样的一个二维数组和一个整数,判断数组中是否包含此整数.

### 2.3.2. 字符串

1. [面试题4 :替换空格](https://github.com/lidong20141226/sfoddjoker/blob/master/src/main/java/chapter/chapter02/insertintoarray/InsertInAarry.java)及其
   [测试用例](https://github.com/lidong20141226/sfoddjoker/blob/master/src/test/java/chapter/chapter02/insertintoarray/InsertInAarryTest.java#L8)
2. [插入排序算法](https://github.com/lidong20141226/sfoddjoker/blob/master/src/test/java/chapter/chapter02/insertintoarray/ArrayIntoArray.java#L7)

### 2.3.3. 链表

链表的空间效率较高,没有空闲的内存.相对的在操作上的时间效率较低,数组的时间效率为O(1),而链表的为O(n).

>**常考的面试题**

>>1. [面试题5 从尾到头输出链表.](https://github.com/lidong20141226/sfoddjoker/blob/master/src/test/java/chapter/chapter02/linkmodel/SinglyLinkListTest.java#L9)
>>2. 面试题13 在O(1)时间内删除链表节点.
>>3. 面试题15 在链表的倒数第K个节点
>>4. 面试题16 反转链表
>>5. 面试题17 合并两个排序的链表
>>6. 面试题37 两个链表的第一个公共节点

**衍生部分**

1. 面试题45 圆圈内最后剩下的数字
   (将链表的末尾指针指向头节点,形成环形链表)
2. 面试题27 二叉搜索树与双向链表
3. 面试题26
   复杂链表的复制(链表中的节点中除了有指向下一个节点的指针,还有指向任意节点的指针.(复杂链表))

### 2.3.4. 树

主要考察复杂指针操作情况下写代码的能力.大部分面试中提到的都是二叉树.

二叉树是一种每个节点只有两个子节点的树.常用操作为遍历(按照一定顺序访问树中节点).

#### 常用的遍历方式

1.  前序遍历: 先访问根节点,再访问左子节点,最后访问右子节点
2.  中序遍历: 先访问座子节点,再访问根节点,最后访问右子节点
3.  后序遍历: 先访问左子节点,再访问右子节点,最后访问根节点.

三种都有递归和循环两种不同方式实现,每一种递归都比循环实现简洁得多.

>**面试题目**

>>1. 面试题39 二叉树的深度
>>2. 面试题18 树的子结构
>>3. 面试题26 二叉树中和为某一值的路径
>>4. [面试题 6:重建二叉树](https://github.com/ddjoker/sfoddjoker/blob/master/src/main/java/chapter/chapter02/tree/BtreeUtil.java#L218-L218)
>>5. [面试题24 二叉树的后续遍历序列](https://github.com/ddjoker/sfoddjoker/blob/master/src/main/java/chapter/chapter02/tree/BtreeUtil.java#L157-L157)

#### 三种遍历的6种实现方式

1. 宽度优先遍历:先访问树的第一层,再访问第二层 .... 一直到最后一层.
   在同一层中从左到右顺序依次遍历.我们可以对包括二叉树以内的所有树进行宽度优先遍历.

   >面试题23 从上到下遍历二叉树

2. 二叉搜索树：左子节点总是小于或等于根节点，又子节点总是大于或者等于根节点。

   >面试题50 ： 树中两个节点的最低公共祖先
   >
   >面试题27 ： 二叉搜索树欲双向链表

3. 堆：

   1. 最大堆：最大堆中根节点值最大。
   2. 最小堆：根节点值最小。

4. 红黑树：将树中节点定义为红色和黑色，并通过规则保证从根节点到叶节点的最长路径不超过最短路径的二倍。

   >面试题30 ： 求最小的K个数字。

### 2.3.5. 栈和队列

操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址及临时变量等。
栈的特点是后进先出，即最后被压入（push）栈的元素第一个被弹出（pop）。
>面试题22 栈的压入、弹出序列

通常栈不考虑排序，需要O(n)时间才能找到栈中最大或者最小的元素。在O(1)时间内获取最大或者最小值，需要对栈做特殊设计。
>面试题 21 包含min函数的栈

队列的特点是先进先出。
>面试题23 从上到下遍历二叉树

> [面试题7 用两个栈实现队列](https://github.com/ddjoker/sfoddjoker/blob/master/src/main/java/chapter/chapter02/stack2queue/CQueue.java)

### 2.4. 算法和数据操作

排序和查找是面试时考察算法的重点。

1. [二分查找](https://github.com/ddjoker/sfoddjoker/blob/master/src/main/java/chapter/chapter02/search/BinarySearch.java#L10-L10)
2. 归并排序
3. 快速排序

算法的实现一般都会使用递归和循环两种方式实现。通常递归方式比较简洁，但是性能不如循环的实现方式。

位运算是一类特殊的算法,他是把数字表示成二进制之后对0和1的操作。一般只有，与、或、异或、左移、右移5种运算符。

#### 2.4.1. 查找和排序

查找：顺序查找、
[二分查找](https://github.com/ddjoker/sfoddjoker/blob/master/src/main/java/chapter/chapter02/search/BinarySearch.java#L10-L10)、
哈希查找和二叉树排序查找。

> 如果面试题要求在排序的数组（部分排序的数组）中查找一个数字或者统计某个数字出现的次数，都可以尝试使用二分查找来实现

哈希表和二叉树主要重点考察于对应的数据结构而不是算法。哈希的优点是可以在O(1)时间来查找某一个元素，是效率最高的查找算法。缺点是需要额外的空间实现哈希表
>面试题35 ： 第一个只出现一次的字符

与二叉排序树对应的数据结构就是二叉搜索树。

>面试题23 ：二叉搜索树的后序遍历序列
>面试题27： 二叉树与双向链表

排序 ： 比较插入排序、冒泡排序、归并排序、
快速排序等不同算法的优劣。需要从额外空间消耗、平均时间复杂度和最差时间复杂度等方面比较。

>[排序算法的稳定性比较](https://github.com/ddjoker/sfoddjoker/blob/master/src/main/resources/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F.md)

>面试题8 ： 旋转组的最小数字
>>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
>>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2,}为{1,2,3,4,5}
>>的一个旋转 ，该数组的最小值为1。





